{"cells":[{"cell_type":"markdown","id":"fifteen-sailing","metadata":{"id":"fifteen-sailing"},"source":["# Лабораторная работа №2\n","## Выполнил студент группы ФИО ГРУППА"]},{"cell_type":"markdown","id":"arctic-stocks","metadata":{"id":"arctic-stocks"},"source":["Реализовать следующие структуры данных:\n","  \n","● <b> Стек (stack): </b>  \n","Операции для стека:\n","<i> инициализация, проверка на пустоту, добавление нового элемента в начало, извлечение элемента из начала;  </i>  \n","  \n","● <b> Дек (двусторонняя очередь, deque):  </b>  \n","Операции для дека:\n","<i> инициализация, проверка на пустоту, добавление нового элемента в начало, добавление нового элемента в конец, извлечение элемента из начала, извлечение элемента из конца. </i>  \n","  \n","<i> Разработать программу обработки данных, содержащихся в заранее подготовленном txt-файле, в соответствии с заданиями, применив указанную в задании структуру данных. Результат работы программы вывести на экран и сохранить в отдельном txt-файле. </i>"]},{"cell_type":"markdown","id":"5d7edb08","metadata":{"scrolled":true,"id":"5d7edb08"},"source":["### Задание №1\n","Отсортировать строки файла, содержащие названия книг, в алфавитном порядке с использованием двух деков."]},{"cell_type":"code","execution_count":2,"id":"17702ade","metadata":{"id":"17702ade","colab":{"base_uri":"https://localhost:8080/","height":356},"executionInfo":{"status":"error","timestamp":1741033414034,"user_tz":-180,"elapsed":28351,"user":{"displayName":"Ngungui Mazembe","userId":"16166709129145843835"}},"outputId":"c6660087-5664-4d47-87a4-17e5c8184122"},"outputs":[{"output_type":"error","ename":"KeyboardInterrupt","evalue":"","traceback":["\u001b[0;31m---------------------------------------------------------------------------\u001b[0m","\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)","\u001b[0;32m<ipython-input-2-681295dd83f3>\u001b[0m in \u001b[0;36m<cell line: 0>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     85\u001b[0m \u001b[0;31m# Запуск сортировки\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     86\u001b[0m \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 87\u001b[0;31m     \u001b[0msort_books\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minput_filename\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0moutput_filename\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     88\u001b[0m     \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34mf\"Сортировка завершена. Результат сохранён в {output_filename}\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     89\u001b[0m \u001b[0;32mexcept\u001b[0m \u001b[0mFileNotFoundError\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m<ipython-input-2-681295dd83f3>\u001b[0m in \u001b[0;36msort_books\u001b[0;34m(input_file, output_file)\u001b[0m\n\u001b[1;32m     55\u001b[0m     \u001b[0;32mwhile\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mdeque1\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mis_empty\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     56\u001b[0m         \u001b[0mmin_value\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdeque1\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mremove_front\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 57\u001b[0;31m         \u001b[0;32mwhile\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mdeque1\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mis_empty\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     58\u001b[0m             \u001b[0mitem\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mdeque1\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mremove_front\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     59\u001b[0m             \u001b[0;32mif\u001b[0m \u001b[0mitem\u001b[0m \u001b[0;34m<\u001b[0m \u001b[0mmin_value\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;32m<ipython-input-2-681295dd83f3>\u001b[0m in \u001b[0;36mis_empty\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m     23\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdeque\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     24\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 25\u001b[0;31m     \u001b[0;32mdef\u001b[0m \u001b[0mis_empty\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     26\u001b[0m         \u001b[0;32mreturn\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdeque\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;36m0\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     27\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n","\u001b[0;31mKeyboardInterrupt\u001b[0m: "]}],"source":["class Stack:\n","    def __init__(self):\n","        self.stack = []\n","\n","    def is_empty(self):\n","        return len(self.stack) == 0\n","\n","    def push(self, item):\n","        self.stack.append(item)\n","\n","    def pop(self):\n","        if self.is_empty():\n","            return None\n","        return self.stack.pop()\n","\n","    def peek(self):\n","        if self.is_empty():\n","            return None\n","        return self.stack[-1]\n","\n","class Deque:\n","    def __init__(self):\n","        self.deque = []\n","\n","    def is_empty(self):\n","        return len(self.deque) == 0\n","\n","    def add_front(self, item):\n","        self.deque.insert(0, item)\n","\n","    def add_rear(self, item):\n","        self.deque.append(item)\n","\n","    def remove_front(self):\n","        if self.is_empty():\n","            return None\n","        return self.deque.pop(0)\n","\n","    def remove_rear(self):\n","        if self.is_empty():\n","            return None\n","        return self.deque.pop()\n","\n","# Функция для сортировки строк с использованием двух деков\n","def sort_books(input_file, output_file):\n","    deque1 = Deque()\n","    deque2 = Deque()\n","\n","    with open(input_file, 'r', encoding='utf-8') as file:\n","        lines = [line.strip() for line in file.readlines() if line.strip()]\n","\n","    for line in lines:\n","        deque1.add_rear(line)\n","\n","    while not deque1.is_empty():\n","        min_value = deque1.remove_front()\n","        while not deque1.is_empty():\n","            item = deque1.remove_front()\n","            if item < min_value:\n","                deque2.add_rear(min_value)\n","                min_value = item\n","            else:\n","                deque2.add_rear(item)\n","        deque1, deque2 = deque2, deque1\n","        deque2.add_rear(min_value)\n","\n","    sorted_books = []\n","    while not deque2.is_empty():\n","        sorted_books.append(deque2.remove_front())\n","\n","    # Запись результата в файл\n","    with open(output_file, 'w', encoding='utf-8') as file:\n","        for book in sorted_books:\n","            file.write(book + '\\n')\n","\n","    # Вывод результата в консоль\n","    print(\"--- Отсортированные книги ---\")\n","    for book in sorted_books:\n","        print(book)\n","\n","# Файлы ввода и вывода\n","input_filename = \"input.txt\"\n","output_filename = \"output.txt\"\n","\n","# Запуск сортировки\n","try:\n","    sort_books(input_filename, output_filename)\n","    print(f\"Сортировка завершена. Результат сохранён в {output_filename}\")\n","except FileNotFoundError:\n","    print(f\"Ошибка: файл {input_filename} не найден.\")\n"]},{"cell_type":"markdown","id":"49fbd2a0","metadata":{"id":"49fbd2a0"},"source":["### Задание №2\n","Дек содержит последовательность символов для шифровки сообщений. Дан текстовый файл, содержащий зашифрованное сообщение. Пользуясь деком, расшифровать текст.\n","Известно, что при шифровке каждый символ сообщения заменялся следующим за ним в деке по часовой стрелке через один."]},{"cell_type":"code","execution_count":3,"id":"81cab7a8","metadata":{"id":"81cab7a8","colab":{"base_uri":"https://localhost:8080/"},"executionInfo":{"status":"ok","timestamp":1741033427152,"user_tz":-180,"elapsed":72,"user":{"displayName":"Ngungui Mazembe","userId":"16166709129145843835"}},"outputId":"b0627ac6-3502-4085-f544-ef026c66088a"},"outputs":[{"output_type":"stream","name":"stdout","text":["Ошибка: файл encrypted.txt не найден.\n"]}],"source":["class Stack:\n","    def __init__(self):\n","        self.stack = []\n","\n","    def is_empty(self):\n","        return len(self.stack) == 0\n","\n","    def push(self, item):\n","        self.stack.append(item)\n","\n","    def pop(self):\n","        if self.is_empty():\n","            return None\n","        return self.stack.pop()\n","\n","    def peek(self):\n","        if self.is_empty():\n","            return None\n","        return self.stack[-1]\n","\n","class Deque:\n","    def __init__(self):\n","        self.deque = []\n","\n","    def is_empty(self):\n","        return len(self.deque) == 0\n","\n","    def add_front(self, item):\n","        self.deque.insert(0, item)\n","\n","    def add_rear(self, item):\n","        self.deque.append(item)\n","\n","    def remove_front(self):\n","        if self.is_empty():\n","            return None\n","        return self.deque.pop(0)\n","\n","    def remove_rear(self):\n","        if self.is_empty():\n","            return None\n","        return self.deque.pop()\n","\n","    def rotate_clockwise(self, steps=1):\n","        for _ in range(steps):\n","            if not self.is_empty():\n","                self.deque.insert(0, self.deque.pop())\n","\n","    def rotate_counterclockwise(self, steps=1):\n","        for _ in range(steps):\n","            if not self.is_empty():\n","                self.deque.append(self.deque.pop(0))\n","\n","# Функция для расшифровки сообщения\n","def decrypt_message(input_file, output_file, sequence):\n","    deque = Deque()\n","    for char in sequence:\n","        deque.add_rear(char)\n","\n","    with open(input_file, 'r', encoding='utf-8') as file:\n","        encrypted_text = file.read().strip()\n","\n","    decrypted_text = \"\"\n","    for char in encrypted_text:\n","        if char in deque.deque:\n","            index = deque.deque.index(char)\n","            deque.rotate_counterclockwise(index + 1)  # Смещение в обратную сторону\n","            decrypted_text += deque.deque[0]\n","            deque.rotate_clockwise(index + 1)  # Возвращаем исходный порядок\n","        else:\n","            decrypted_text += char\n","\n","    # Запись расшифрованного текста в файл\n","    with open(output_file, 'w', encoding='utf-8') as file:\n","        file.write(decrypted_text)\n","\n","    # Вывод расшифрованного текста в консоль\n","    print(\"--- Расшифрованное сообщение ---\")\n","    print(decrypted_text)\n","\n","# Файлы ввода и вывода\n","input_filename = \"encrypted.txt\"\n","output_filename = \"decrypted.txt\"\n","char_sequence = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,!? \"  # Пример последовательности символов\n","\n","# Расшифровка сообщения\n","try:\n","    decrypt_message(input_filename, output_filename, char_sequence)\n","    print(f\"Расшифровка завершена. Результат сохранён в {output_filename}\")\n","except FileNotFoundError:\n","    print(f\"Ошибка: файл {input_filename} не найден.\")\n"]},{"cell_type":"markdown","id":"c0894f47","metadata":{"id":"c0894f47"},"source":["### Задание №3\n","Даны три стержня и n дисков различного размера. Диски можно надевать на стержни, образуя из них башни. Перенести n дисков со стержня А на стержень С, сохранив их первоначальный порядок. При переносе дисков необходимо соблюдать следующие правила:\n","- на каждом шаге со стержня на стержень переносить только один диск;\n","- диск нельзя помещать на диск меньшего размера;\n","- для промежуточного хранения можно использовать стержень В.\n","Реализовать алгоритм, используя три стека вместо стержней А, В, С. Информация о дисках хранится в исходном файле."]},{"cell_type":"code","execution_count":null,"id":"9e91a9d4","metadata":{"id":"9e91a9d4"},"outputs":[],"source":["class Stack:\n","    def __init__(self):\n","        self.stack = []\n","\n","    def is_empty(self):\n","        return len(self.stack) == 0\n","\n","    def push(self, item):\n","        self.stack.append(item)\n","\n","    def pop(self):\n","        if self.is_empty():\n","            return None\n","        return self.stack.pop()\n","\n","    def peek(self):\n","        if self.is_empty():\n","            return None\n","        return self.stack[-1]\n","\n","# Функция перемещения дисков\n","def move_disks(n, source, target, auxiliary):\n","    if n > 0:\n","        move_disks(n - 1, source, auxiliary, target)\n","        disk = source.pop()\n","        if disk is not None:\n","            target.push(disk)\n","            print(f\"Переместить диск {disk} со стержня {source.name} на {target.name}\")\n","        move_disks(n - 1, auxiliary, target, source)\n","\n","# Функция для чтения данных и решения задачи Ханойской башни\n","def solve_hanoi(input_file, output_file):\n","    with open(input_file, 'r', encoding='utf-8') as file:\n","        disks = [int(line.strip()) for line in file.readlines() if line.strip().isdigit()]\n","\n","    source = Stack()\n","    target = Stack()\n","    auxiliary = Stack()\n","\n","    source.name = \"A\"\n","    target.name = \"C\"\n","    auxiliary.name = \"B\"\n","\n","    for disk in sorted(disks, reverse=True):\n","        source.push(disk)\n","\n","    print(\"--- Начало перемещения ---\")\n","    move_disks(len(disks), source, target, auxiliary)\n","    print(\"--- Перемещение завершено ---\")\n","\n","    # Запись результата в файл\n","    with open(output_file, 'w', encoding='utf-8') as file:\n","        while not target.is_empty():\n","            file.write(str(target.pop()) + '\\n')\n","    print(f\"Результат сохранён в {output_file}\")\n","\n","# Файлы ввода и вывода\n","input_filename = \"hanoi_input.txt\"\n","output_filename = \"hanoi_output.txt\"\n","\n","# Решение задачи Ханойской башни\n","try:\n","    solve_hanoi(input_filename, output_filename)\n","except FileNotFoundError:\n","    print(f\"Ошибка: файл {input_filename} не найден.\")\n"]},{"cell_type":"markdown","id":"e5b0be17","metadata":{"id":"e5b0be17"},"source":["### Задание №4\n","Дан текстовый файл с программой на алгоритмическом языке. За один просмотр файла проверить баланс круглых скобок в тексте, используя стек."]},{"cell_type":"code","execution_count":null,"id":"5b1df60a","metadata":{"id":"5b1df60a"},"outputs":[],"source":["class Stack:\n","    def __init__(self):\n","        self.stack = []\n","\n","    def is_empty(self):\n","        return len(self.stack) == 0\n","\n","    def push(self, item):\n","        self.stack.append(item)\n","\n","    def pop(self):\n","        if self.is_empty():\n","            return None\n","        return self.stack.pop()\n","\n","    def peek(self):\n","        if self.is_empty():\n","            return None\n","        return self.stack[-1]\n","\n","# Функция проверки баланса круглых скобок\n","def check_parentheses_balance(input_file):\n","    stack = Stack()\n","\n","    with open(input_file, 'r', encoding='utf-8') as file:\n","        text = file.read()\n","\n","    for char in text:\n","        if char == '(':\n","            stack.push(char)\n","        elif char == ')':\n","            if stack.is_empty():\n","                return False  # Закрывающая скобка без открывающей\n","            stack.pop()\n","\n","    return stack.is_empty()  # Если стек пустой, баланс соблюден\n","\n","# Файлы ввода\n","input_filename = \"program.txt\"\n","\n","# Проверка баланса скобок\n","try:\n","    if check_parentheses_balance(input_filename):\n","        print(\"Баланс скобок соблюден.\")\n","    else:\n","        print(\"Ошибка: несбалансированные скобки.\")\n","except FileNotFoundError:\n","    print(f\"Ошибка: файл {input_filename} не найден.\")\n"]},{"cell_type":"markdown","id":"c44cdd6b","metadata":{"id":"c44cdd6b"},"source":["### Задание №5\n","Дан текстовый файл с программой на алгоритмическом языке. За один просмотр файла проверить баланс квадратных скобок в тексте, используя дек."]},{"cell_type":"code","execution_count":null,"id":"36b8f400","metadata":{"id":"36b8f400"},"outputs":[],"source":["class Stack:\n","    def __init__(self):\n","        self.stack = []\n","\n","    def is_empty(self):\n","        return len(self.stack) == 0\n","\n","    def push(self, item):\n","        self.stack.append(item)\n","\n","    def pop(self):\n","        if self.is_empty():\n","            return None\n","        return self.stack.pop()\n","\n","    def peek(self):\n","        if self.is_empty():\n","            return None\n","        return self.stack[-1]\n","\n","class Deque:\n","    def __init__(self):\n","        self.deque = []\n","\n","    def is_empty(self):\n","        return len(self.deque) == 0\n","\n","    def add_front(self, item):\n","        self.deque.insert(0, item)\n","\n","    def add_rear(self, item):\n","        self.deque.append(item)\n","\n","    def remove_front(self):\n","        if self.is_empty():\n","            return None\n","        return self.deque.pop(0)\n","\n","    def remove_rear(self):\n","        if self.is_empty():\n","            return None\n","        return self.deque.pop()\n","\n","# Функция проверки баланса квадратных скобок\n","def check_square_brackets_balance(input_file):\n","    deque = Deque()\n","\n","    with open(input_file, 'r', encoding='utf-8') as file:\n","        text = file.read()\n","\n","    for char in text:\n","        if char == '[':\n","            deque.add_rear(char)\n","        elif char == ']':\n","            if deque.is_empty():\n","                return False  # Закрывающая скобка без открывающей\n","            deque.remove_rear()\n","\n","    return deque.is_empty()  # Если дек пуст, баланс соблюден\n","\n","# Файлы ввода\n","input_filename = \"program.txt\"\n","\n","# Проверка баланса квадратных скобок\n","try:\n","    if check_square_brackets_balance(input_filename):\n","        print(\"Баланс квадратных скобок соблюден.\")\n","    else:\n","        print(\"Ошибка: несбалансированные квадратные скобки.\")\n","except FileNotFoundError:\n","    print(f\"Ошибка: файл {input_filename} не найден.\")\n"]},{"cell_type":"markdown","id":"59d13dc7","metadata":{"id":"59d13dc7"},"source":["### Задание №6\n","Дан файл из символов. Используя стек, за один просмотр файла напечатать сначала все цифры, затем все буквы, и, наконец, все остальные символы, сохраняя исходный порядок в каждой группе символов."]},{"cell_type":"code","execution_count":null,"id":"297e36c2","metadata":{"id":"297e36c2"},"outputs":[],"source":["class Stack:\n","    def __init__(self):\n","        self.stack = []\n","\n","    def is_empty(self):\n","        return len(self.stack) == 0\n","\n","    def push(self, item):\n","        self.stack.append(item)\n","\n","    def pop(self):\n","        if self.is_empty():\n","            return None\n","        return self.stack.pop()\n","\n","    def peek(self):\n","        if self.is_empty():\n","            return None\n","        return self.stack[-1]\n","\n","# Функция для разделения символов и печати в заданном порядке\n","def process_file_by_character_type(input_file):\n","    digits_stack = Stack()\n","    letters_stack = Stack()\n","    others_stack = Stack()\n","\n","    with open(input_file, 'r', encoding='utf-8') as file:\n","        text = file.read()\n","\n","    digits = []\n","    letters = []\n","    others = []\n","\n","    for char in text:\n","        if char.isdigit():\n","            digits.append(char)\n","        elif char.isalpha():\n","            letters.append(char)\n","        else:\n","            others.append(char)\n","\n","    for char in digits:\n","        digits_stack.push(char)\n","    for char in letters:\n","        letters_stack.push(char)\n","    for char in others:\n","        others_stack.push(char)\n","\n","    result = \"\".join(digits + letters + others)\n","\n","    print(\"--- Отсортированные символы ---\")\n","    print(result)\n","\n","    return result\n","\n","# Файлы ввода\n","input_filename = \"characters.txt\"\n","\n","# Обработка файла\n","try:\n","    sorted_result = process_file_by_character_type(input_filename)\n","    with open(\"sorted_output.txt\", 'w', encoding='utf-8') as file:\n","        file.write(sorted_result)\n","    print(\"Результат сохранен в sorted_output.txt\")\n","except FileNotFoundError:\n","    print(f\"Ошибка: файл {input_filename} не найден.\")\n"]},{"cell_type":"markdown","id":"973f68bd","metadata":{"id":"973f68bd"},"source":["### Задание №7\n","Дан файл из целых чисел. Используя дек, за один просмотр файла напечатать сначала все отрицательные числа, затем все положительные числа, сохраняя исходный порядок в каждой группе."]},{"cell_type":"code","execution_count":null,"id":"c56fad66","metadata":{"id":"c56fad66"},"outputs":[],"source":["class Deque:\n","    def __init__(self):\n","        self.deque = []\n","\n","    def is_empty(self):\n","        return len(self.deque) == 0\n","\n","    def add_front(self, item):\n","        self.deque.insert(0, item)\n","\n","    def add_rear(self, item):\n","        self.deque.append(item)\n","\n","    def remove_front(self):\n","        if self.is_empty():\n","            return None\n","        return self.deque.pop(0)\n","\n","    def remove_rear(self):\n","        if self.is_empty():\n","            return None\n","        return self.deque.pop()\n","\n","# Функция для сортировки чисел по знаку\n","def process_numbers_by_sign(input_file):\n","    negative_deque = Deque()\n","    positive_deque = Deque()\n","\n","    with open(input_file, 'r', encoding='utf-8') as file:\n","        numbers = [int(num) for num in file.read().split() if num.lstrip('-').isdigit()]\n","\n","    for num in numbers:\n","        if num < 0:\n","            negative_deque.add_rear(num)\n","        else:\n","            positive_deque.add_rear(num)\n","\n","    result = [str(negative_deque.remove_front()) for _ in range(len(negative_deque.deque))] + \\\n","             [str(positive_deque.remove_front()) for _ in range(len(positive_deque.deque))]\n","\n","    result_text = \" \".join(result)\n","\n","    print(\"--- Отсортированные числа ---\")\n","    print(result_text)\n","\n","    return result_text\n","\n","# Файлы ввода\n","input_filename = \"numbers.txt\"\n","\n","# Обработка файла\n","try:\n","    sorted_result = process_numbers_by_sign(input_filename)\n","    with open(\"sorted_numbers_output.txt\", 'w', encoding='utf-8') as file:\n","        file.write(sorted_result)\n","    print(\"Результат сохранен в sorted_numbers_output.txt\")\n","except FileNotFoundError:\n","    print(f\"Ошибка: файл {input_filename} не найден.\")\n"]},{"cell_type":"markdown","id":"b9228191","metadata":{"id":"b9228191"},"source":["### Задание №8\n","Дан текстовый файл. Используя стек, сформировать новый текстовый файл, содержащий строки исходного файла, записанные в обратном порядке: первая строка становится последней, вторая – предпоследней и т.д."]},{"cell_type":"code","execution_count":null,"id":"981fbdfe","metadata":{"id":"981fbdfe"},"outputs":[],"source":["class Stack:\n","    def __init__(self):\n","        self.stack = []\n","\n","    def is_empty(self):\n","        return len(self.stack) == 0\n","\n","    def push(self, item):\n","        self.stack.append(item)\n","\n","    def pop(self):\n","        if self.is_empty():\n","            return None\n","        return self.stack.pop()\n","\n","# Функция для переворачивания строк файла\n","def reverse_file_lines(input_file, output_file):\n","    stack = Stack()\n","\n","    with open(input_file, 'r', encoding='utf-8') as file:\n","        lines = file.readlines()\n","\n","    for line in lines:\n","        stack.push(line.strip())\n","\n","    with open(output_file, 'w', encoding='utf-8') as file:\n","        while not stack.is_empty():\n","            file.write(stack.pop() + '\\n')\n","\n","    print(f\"Файл {output_file} создан с перевернутыми строками.\")\n","\n","# Файлы ввода и вывода\n","input_filename = \"input.txt\"\n","output_filename = \"reversed_output.txt\"\n","\n","# Запуск переворота строк\n","try:\n","    reverse_file_lines(input_filename, output_filename)\n","except FileNotFoundError:\n","    print(f\"Ошибка: файл {input_filename} не найден.\")\n"]},{"cell_type":"markdown","id":"rental-jerusalem","metadata":{"id":"rental-jerusalem"},"source":["### Вывод\n"]},{"cell_type":"markdown","id":"0c2b8899","metadata":{"id":"0c2b8899"},"source":[]}],"metadata":{"kernelspec":{"display_name":"Python 3 (ipykernel)","language":"python","name":"python3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.10.2"},"colab":{"provenance":[{"file_id":"1F6DD9uDuOadW6SgB7apzp3MgMQx5Qfla","timestamp":1741032490881},{"file_id":"1SJnopeql2j1MhzcaJ8o68KaPzPnynIeK","timestamp":1740998365614}]}},"nbformat":4,"nbformat_minor":5}